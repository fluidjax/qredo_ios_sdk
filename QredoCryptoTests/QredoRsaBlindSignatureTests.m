/*
 *  Copyright (c) 2011-2016 Qredo Ltd.  Strictly confidential.  All rights reserved.
 */

#import <UIKit/UIKit.h>
#import <XCTest/XCTest.h>
#import "QredoRsaBlindSignature.h"
//#import "tommath.h"
#import "QredoLoggerPrivate.h"
#import "QredoCrypto.h"

@interface QredoRsaBlindSignatureTests : XCTestCase

@end

@implementation QredoRsaBlindSignatureTests

- (void)setUp {
    [super setUp];
    // Put setup code here. This method is called before the invocation of each test method in the class.
    
    // Must remove any existing keys before starting
    [QredoCrypto deleteAllKeysInAppleKeychain];
}

- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
    [super tearDown];
    
    // Must remove any keys after completing
    [QredoCrypto deleteAllKeysInAppleKeychain];
}

//- (void)testBlindMessage
//{
//    size_t keyLengthBytes = 1024 / 8; // 1024 bit key
//    uint8_t modulus[] = {0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t modulusLength = sizeof(modulus) / sizeof(uint8_t);
//    XCTAssert(modulusLength == keyLengthBytes, @"Modulus not initialised with correct number of elements.");
//    
//    uint8_t privateExponent[] = {0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t privateExponentLength = sizeof(privateExponent) / sizeof(uint8_t);
//    XCTAssert(privateExponentLength == keyLengthBytes, @"Private Expnent not initialised with correct number of elements.");
//
//    uint8_t publicExponent[] = {0x01,0x00,0x01};
//    size_t publicExponentLength = sizeof(publicExponent) / sizeof(uint8_t);
//    
//    // Nelly the elephant packed her trunk
//    uint8_t message[] = {0x4E,0x65,0x6C,0x6C,0x79,0x20,0x74,0x68,0x65,0x20,0x65,0x6C,0x65,0x70,0x68,0x61,0x6E,0x74,0x20,0x70,0x61,0x63,0x6B,0x65,0x64,0x20,0x68,0x65,0x72,0x20,0x74,0x72,0x75,0x6E,0x6B};
//    size_t messageLength = sizeof(message) / sizeof(uint8_t);
//
//    uint8_t blindedMessage[keyLengthBytes];
//    size_t blindedMessageLength = sizeof(blindedMessage) / sizeof(uint8_t);
//    
//    uint8_t blindingFactor[keyLengthBytes];
//    size_t blindingFactorLength = sizeof(blindingFactor) / sizeof(uint8_t);
//    
//    int result = blindMessage(modulus, modulusLength, publicExponent, publicExponentLength, message, messageLength, blindingFactor, &blindingFactorLength, blindedMessage, &blindedMessageLength);
//    
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Message blinding failed.");
//    
//}
//
//- (void)testUnblindSignature
//{
//    size_t keyLengthBytes = 1024 / 8; // 1024 bit key
//    uint8_t modulus[] = {0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t modulusLength = sizeof(modulus) / sizeof(uint8_t);
//    XCTAssert(modulusLength == keyLengthBytes, @"Modulus not initialised with correct number of elements.");
//    
//    uint8_t blindingFactor[] = {0x98,0x58,0x49,0x96,0xDB,0x9B,0x99,0x3F,0xDD,0x6E,0x25,0x89,0x7C,0x17,0x51,0xAF,0x77,0x78,0x72,0xC7,0xDC,0xE1,0xB9,0xEF,0x25,0x28,0xC5,0xB3,0x2A,0x92,0x08,0xDD,0x66,0x79,0x47,0xBC,0xA2,0xF7,0x6D,0xB8,0xEA,0x1C,0xDB,0x4B,0x1E,0xB5,0xBD,0x7C,0xEA,0x25,0x4C,0x1B,0xC7,0xDB,0xEB,0xBB,0x29,0xAC,0x21,0x55,0x9A,0xE9,0x67,0x99,0x76,0xD4,0xA9,0x0D,0x10,0x48,0xF1,0x89,0x77,0x81,0x17,0xA8,0x63,0x50,0xBC,0x7C,0xC0,0x75,0xC3,0x71,0xF3,0x87,0xE2,0x76,0xD6,0x40,0xD2,0x5B,0xA3,0x8C,0x7F,0xEA,0xAF,0x47,0x69,0xB2,0x5F,0xF7,0x87,0xBD,0xB2,0xE7,0x2D,0x83,0xD1,0xFC,0xFE,0x46,0x44,0xC9,0x33,0xE3,0x7F,0xAB,0x1A,0x99,0x7E,0x25,0x36,0xA0,0xCC,0x79,0xA8,0xD3};
//    size_t blindingFactorLength = sizeof(blindingFactor) / sizeof(uint8_t);
//
//    uint8_t blindedSignature[] = {0x51,0x26,0x1B,0xC5,0x72,0xBA,0x92,0x10,0x29,0x91,0x27,0xF1,0xBF,0x5E,0x35,0x81,0x7E,0xA9,0xC1,0x6F,0x5B,0x2C,0x69,0xFC,0xA3,0x1C,0xB3,0xCE,0x75,0xD6,0x68,0x13,0x38,0x59,0x61,0xD1,0x70,0x8B,0xA7,0xFC,0x61,0xA3,0x89,0xDE,0x70,0xAC,0xD8,0x0C,0x02,0x3B,0x73,0xE3,0x0F,0xF8,0x7D,0x16,0xDD,0xF8,0x15,0xBE,0x20,0x73,0xD9,0xA7,0x77,0x30,0x11,0x44,0x9F,0xF6,0xAA,0x9E,0x86,0xBC,0xC0,0xC6,0x4B,0x64,0xBF,0x2A,0x84,0x11,0x5C,0x7A,0xF7,0x24,0x6B,0x1A,0xB6,0xE8,0x7E,0xEB,0xEA,0xAC,0x01,0x55,0xED,0xEF,0xE4,0x9C,0x13,0xA9,0xA8,0x14,0x24,0x4F,0x6F,0xD0,0x50,0x39,0x98,0xCD,0x56,0x71,0x3E,0x9C,0x97,0xBA,0x16,0x71,0xB6,0x9E,0xCF,0x4B,0x2D,0x7A,0x26,0x4A};
//    size_t blindedSignatureLength = sizeof(blindedSignature) / sizeof(uint8_t);
//    
//    uint8_t unblindedSignature[keyLengthBytes];
//    size_t unblindedSignatureLength = sizeof(unblindedSignature) / sizeof(uint8_t);
//    
//    int result = unblindSignature(modulus, modulusLength, blindingFactor, blindingFactorLength, blindedSignature, blindedSignatureLength, unblindedSignature, &unblindedSignatureLength);
//    
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Unblinding failed.");
//}
//
//- (void)testBlindSignUnblindRoundTrip
//{
//    // NOTE: This test will fail if the key has already been imported (even with different identifier)
//    // Import the key data into the keychain (needed as signing uses the KeyChain).
//    // Note, this must match the modulus/exponent arrays below as blinding (C code) uses same key data
//    NSString *keyIdentifier = @"com.qredo.TestPrivateKeyImport1";
//    NSInteger keySizeBits = 1024;
//    BOOL isPrivate = YES;
//    // Manual key data from Bouncy Castle
//    uint8_t keyDataArray[] = {0x30,0x82,0x02,0x5B,0x02,0x01,0x00,0x02,0x81,0x81,0x00,0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF,0x02,0x03,0x01,0x00,0x01,0x02,0x81,0x80,0x06,0x23,0x87,0xE0,0xF7,0x06,0xF8,0xAE,0x9C,0x39,0x0F,0xE2,0x9D,0xF1,0xF4,0x2D,0xB5,0x09,0x59,0x82,0x68,0xE4,0xEB,0x58,0x4B,0xF3,0x30,0x17,0x69,0x74,0xA2,0xEA,0xAF,0xB0,0xD5,0xF6,0x4A,0x4A,0xFA,0x8C,0x39,0x2C,0xE6,0xF9,0x58,0x03,0xD7,0x0E,0x31,0x7F,0x0E,0x25,0xF0,0xBD,0x2C,0x9C,0x4A,0xE0,0x11,0x2F,0x33,0x15,0x44,0x75,0xE5,0x8B,0x2C,0xC4,0x9F,0x56,0x8E,0x9E,0x26,0xA9,0x1C,0x40,0xAB,0xDA,0xB9,0xF4,0xC8,0x39,0xBD,0xFF,0x82,0xC8,0xB7,0xB9,0x67,0xFE,0x7B,0x53,0xE8,0xB9,0x19,0x22,0xF6,0x41,0xD6,0xD5,0x65,0xBC,0xE5,0x07,0xF2,0x73,0x3B,0x5B,0x28,0xBA,0xBF,0x48,0x9F,0x1E,0xAA,0x45,0x95,0x08,0x62,0xBC,0x72,0xA3,0x06,0xC3,0x9D,0x23,0xD8,0xE1,0x02,0x41,0x00,0xE5,0x22,0xE6,0x8A,0xAE,0xD8,0x94,0xE9,0x83,0xE0,0x91,0x14,0x2E,0xAB,0x43,0x46,0xA5,0x7A,0xD3,0xF9,0x04,0x3D,0x35,0x18,0x31,0x38,0x82,0xA2,0xD3,0x0A,0xD7,0xE2,0x37,0xF8,0x17,0x22,0x08,0xD3,0xBF,0xBC,0xBD,0xFD,0x89,0x8C,0x21,0xCF,0x32,0xED,0x25,0x46,0xD0,0xC2,0x4E,0x50,0x58,0xDD,0x92,0xF5,0xDE,0x64,0x0B,0x3D,0x0A,0x0D,0x02,0x41,0x00,0xCE,0x2F,0x98,0x54,0x2B,0x59,0xC7,0x9D,0xA8,0x9E,0xA1,0x44,0xD7,0xBA,0x47,0x6B,0x23,0xE5,0xB1,0x89,0x8C,0xB4,0xAF,0xD3,0x19,0x0E,0x5A,0x8D,0x07,0xE4,0xF8,0x5B,0x11,0xC4,0x8E,0xCF,0xFB,0x39,0xBC,0xC2,0x9C,0x28,0x83,0xEE,0x3A,0x3E,0x17,0xE1,0xB4,0x3B,0x98,0x05,0xD6,0x8D,0x29,0xAA,0xBE,0x32,0x02,0x41,0x50,0x43,0x67,0x9B,0x02,0x40,0x13,0xD5,0x9E,0x91,0x38,0xAB,0x64,0xD0,0x85,0xEA,0xE5,0x84,0x12,0xBA,0x1E,0x7B,0xBA,0x0D,0x54,0xD6,0x04,0x68,0xEB,0xF4,0xA9,0x26,0x14,0x20,0xD6,0x15,0xE5,0x34,0x1E,0xD6,0x29,0xE2,0x77,0x53,0x25,0x10,0xC8,0x7D,0x6E,0xEF,0xA3,0x69,0x95,0x25,0xF4,0x09,0x1A,0x3F,0x07,0x9A,0x6A,0xE6,0xDB,0x36,0xCF,0x46,0x67,0xB6,0xA3,0xED,0x02,0x40,0x01,0xFF,0x6E,0x0F,0x6A,0xB8,0x1C,0xFA,0x07,0x17,0x3A,0x62,0xCB,0x60,0x4F,0xAE,0xD7,0x13,0x33,0xAC,0x2C,0x83,0xD7,0xAC,0x48,0xF2,0xDD,0xA7,0xBE,0x2A,0xD6,0xC9,0x33,0x1B,0xDF,0x72,0x5E,0x71,0xC9,0xC5,0x6C,0xF3,0xEB,0x8B,0x54,0x5F,0x23,0xA6,0x19,0x33,0xF6,0x9E,0x1F,0xDD,0x10,0x49,0x4A,0x3C,0x7B,0xCF,0x1C,0x32,0xFA,0xFF,0x02,0x40,0x4E,0xBB,0x7C,0xE3,0xA3,0xC2,0xA7,0x8B,0x60,0x08,0xE6,0xC6,0x13,0xF8,0x57,0x44,0xD4,0x69,0xE5,0x67,0xEF,0x22,0x11,0xE3,0x75,0xBE,0x7D,0x1D,0x6E,0x33,0x0D,0x57,0x72,0xC0,0xD6,0x79,0xCD,0xE3,0x9F,0xA7,0xD7,0x99,0x75,0xDA,0x39,0xB7,0xD9,0x29,0x6D,0x28,0x88,0x30,0x37,0x71,0x78,0x99,0x3A,0x73,0xBC,0x60,0x11,0x1B,0x50,0xE0};
//    NSData *keyData = [NSData dataWithBytes:keyDataArray length:sizeof(keyDataArray) / sizeof(uint8_t)];
//    
//    SecKeyRef importKeyRef = [QredoCrypto importPkcs1KeyData:keyData
//                                               keyLengthBits:keySizeBits
//                                               keyIdentifier:keyIdentifier
//                                                   isPrivate:isPrivate];
//    XCTAssertTrue((__bridge id)importKeyRef, @"Key import failed.");
//
//    SecKeyRef privateKey = [QredoCrypto getRsaSecKeyReferenceForIdentifier:keyIdentifier];
//
//    size_t keyLengthBytes = 1024 / 8; // 1024 bit key
//    uint8_t modulus[] = {0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t modulusLength = sizeof(modulus) / sizeof(uint8_t);
//    XCTAssert(modulusLength == keyLengthBytes, @"Modulus not initialised with correct number of elements.");
//    
//    uint8_t privateExponent[] = {0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t privateExponentLength = sizeof(privateExponent) / sizeof(uint8_t);
//    XCTAssert(privateExponentLength == keyLengthBytes, @"Private Expnent not initialised with correct number of elements.");
//    
//    uint8_t publicExponent[] = {0x01,0x00,0x01};
//    size_t publicExponentLength = sizeof(publicExponent) / sizeof(uint8_t);
//    
//    // Nelly the elephant packed her trunk
//    uint8_t message[] = {0x4E,0x65,0x6C,0x6C,0x79,0x20,0x74,0x68,0x65,0x20,0x65,0x6C,0x65,0x70,0x68,0x61,0x6E,0x74,0x20,0x70,0x61,0x63,0x6B,0x65,0x64,0x20,0x68,0x65,0x72,0x20,0x74,0x72,0x75,0x6E,0x6B};
//    size_t messageLength = sizeof(message) / sizeof(uint8_t);
//    
//    uint8_t blindingFactor[keyLengthBytes];
//    size_t blindingFactorLength = sizeof(blindingFactor) / sizeof(uint8_t);
//    
//    uint8_t blindedMessage[keyLengthBytes];
//    size_t blindedMessageLength = sizeof(blindedMessage) / sizeof(uint8_t);
//    
//    int result = blindMessage(modulus, modulusLength, publicExponent, publicExponentLength, message, messageLength, blindingFactor, &blindingFactorLength, blindedMessage, &blindedMessageLength);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Message blinding failed.");
//    
//    // Sign the original and blinded messages and then try unblinding the latter to check signatures are the same
//    uint8_t normalSignature[keyLengthBytes];
//    size_t normalSignatureLength = sizeof(normalSignature) / sizeof(uint8_t);
//    uint8_t blindedSignature[keyLengthBytes];
//    size_t blindedSignatureLength = sizeof(blindedSignature) / sizeof(uint8_t);
//    
//    OSStatus signResult = SecKeyRawSign(privateKey,
//                                        kSecPaddingNone,
//                                        message, messageLength,
//                                        normalSignature, &normalSignatureLength);
//    XCTAssertTrue(signResult == errSecSuccess, @"Signing (original message) failed.");
//
//    signResult = SecKeyRawSign(privateKey,
//                                        kSecPaddingNone,
//                                        blindedMessage, blindedMessageLength,
//                                        blindedSignature, &blindedSignatureLength);
//    XCTAssertTrue(signResult == errSecSuccess, @"Signing (blinded message) failed.");
//    
//    // Unblind the (blinded) signature
//    uint8_t unblindedSignature[keyLengthBytes];
//    size_t unblindedSignatureLength = sizeof(unblindedSignature) / sizeof(uint8_t);
//    
//    result = unblindSignature(modulus, modulusLength, blindingFactor, blindingFactorLength, blindedSignature, blindedSignatureLength, unblindedSignature, &unblindedSignatureLength);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Unblinding failed.");
//
//    // Compare the original and blinded signatures - should be the same
//    NSData *normalSignatureData = [NSData dataWithBytes:normalSignature length:normalSignatureLength];
//    NSData *unblindedSignatureData = [NSData dataWithBytes:unblindedSignature length:unblindedSignatureLength];
//    XCTAssertTrue([unblindedSignatureData isEqualToData:normalSignatureData], @"Unblinded signature and normal signature do not match.");
//}
//
//- (void)testUnblindSignature_BCGeneratedData
//{
//    size_t keyLengthBytes = 1024 / 8; // 1024 bit key
//    uint8_t modulus[] = {0x00,0xB8,0x8C,0xAF,0x43,0xFB,0x4B,0x97,0x6F,0xE6,0x98,0xAC,0x59,0xEE,0xAF,0xED,0x2B,0xD3,0xBC,0x30,0x5A,0x78,0x2B,0xB6,0x65,0x60,0xB3,0xE8,0xD1,0xAD,0xCD,0xC8,0x7E,0x31,0x43,0xD5,0x9F,0x44,0x42,0x54,0x74,0xED,0xD0,0x1B,0x09,0xBE,0xD8,0xE7,0x57,0xE7,0x40,0x4F,0x80,0x1A,0xAB,0x9B,0xA6,0xB1,0x20,0xE3,0x42,0xBB,0x79,0x9A,0xEA,0xEB,0x58,0x67,0x5C,0x48,0x04,0x16,0x9F,0x47,0xA7,0x77,0x23,0x04,0xEA,0xAF,0xBE,0xB9,0xB3,0xEC,0x86,0xE2,0xB4,0x2F,0x62,0x91,0x31,0x2D,0x52,0x26,0xAE,0x45,0x35,0x3B,0x44,0xFF,0x1A,0x7A,0xB1,0x46,0x93,0xF5,0x87,0xF7,0xAE,0x82,0x52,0xD0,0x22,0xBE,0x2E,0x7D,0xF2,0xCE,0xAA,0xC0,0xA2,0x50,0x27,0x92,0x83,0x0E,0x67,0x50,0xDF};
//    size_t modulusLength = sizeof(modulus) / sizeof(uint8_t);
//    
//    uint8_t blindingFactor[] = {0x4C,0x15,0xCE,0x32,0xAC,0x2E,0xE0,0x5D,0x13,0xA2,0xEA,0x6F,0xD8,0xC1,0x02,0xBE,0xC1,0x1C,0x05,0xA6,0x4A,0x71,0x22,0xDD,0x7D,0x2B,0xE2,0x4A,0x45,0x35,0x9E,0xE9,0x6C,0x99,0x64,0xA2,0xAA,0x8F,0xE4,0xF3,0xB8,0x30,0x4B,0x23,0x1A,0x80,0xB2,0x2E,0x04,0x91,0x06,0xD8,0x3B,0x5A,0x4E,0x02,0x00,0x18,0x7A,0x34,0xED,0xB0,0x82,0xE4,0xDD,0x50,0x3B,0x34,0xC6,0x14,0x8C,0x91,0x5B,0x25,0x8F,0x53,0x83,0x7C,0xB2,0xB1,0x25,0xCF,0x91,0xB2,0x63,0x48,0x9A,0x83,0x71,0x71,0x53,0x0F,0xE5,0xC6,0xC7,0x65,0x30,0x0A,0x93,0x11,0xFF,0xFA,0x83,0x3C,0xDA,0x3F,0x10,0x80,0xEA,0xCE,0x36,0x6F,0xB6,0x20,0xDD,0x57,0xBF,0x45,0x1B,0xBC,0xCC,0x55,0xA6,0x81,0xBC,0xCB,0x98,0x78};
//    size_t blindingFactorLength = sizeof(blindingFactor) / sizeof(uint8_t);
//    
//    uint8_t blindedSignature[] = {0x6F,0xC6,0x1A,0x37,0xDF,0x3D,0x43,0xDD,0xA9,0x0A,0x99,0x70,0x6A,0xE5,0x8A,0xCB,0x47,0x5B,0x42,0x74,0x25,0x78,0xA0,0xEE,0xD4,0x3B,0x21,0xB6,0xE3,0x05,0xA7,0x1A,0x82,0xB0,0xD9,0x7B,0xF0,0x33,0x0C,0xB2,0xFF,0x34,0x28,0xFA,0x63,0x64,0x34,0xB9,0xC8,0xE1,0xDE,0xC1,0x82,0x0A,0x98,0x9B,0x8B,0x72,0xA1,0x2F,0xB3,0x8B,0x3A,0x55,0x5A,0x50,0x6B,0x27,0xA8,0xD7,0x26,0x21,0xC8,0x72,0xF2,0x86,0x11,0x75,0x36,0x41,0xA2,0xFC,0xDB,0x6F,0x81,0x04,0xBF,0xBF,0x6D,0x14,0x22,0x68,0xD9,0x57,0xCA,0x85,0xFD,0xFC,0x6D,0xE1,0xA0,0x8E,0xFC,0xD0,0xB7,0x19,0xF1,0x02,0x81,0x8F,0xCF,0x58,0xE2,0x73,0x1E,0x41,0x65,0x2B,0xC7,0x9F,0x1B,0x1C,0x41,0x39,0xD8,0xE7,0x35,0x50};
//    size_t blindedSignatureLength = sizeof(blindedSignature) / sizeof(uint8_t);
//    
//    uint8_t expectedUnblindedSignature[] = {0x57,0x40,0x14,0xF0,0x69,0x13,0xAA,0x39,0x0D,0x0A,0xF5,0xFB,0x9E,0xFE,0x97,0x54,0x67,0xF7,0x50,0x98,0xE0,0x00,0x2D,0x3A,0x00,0xFF,0x63,0x5C,0x98,0x12,0x5C,0x12,0x4F,0x13,0x20,0x42,0xEB,0xD1,0x8F,0xEC,0x3A,0x68,0x08,0xA6,0x83,0x0C,0xF4,0x87,0xEB,0xDB,0x84,0xAF,0x62,0xC7,0x0A,0x81,0xFF,0x80,0xC8,0x67,0xD1,0x40,0x71,0xDD,0xC6,0xD1,0x87,0x7B,0xB5,0x36,0x43,0x9D,0x2B,0x60,0x20,0x02,0x7F,0x6E,0x74,0x0B,0x48,0x20,0xEE,0x62,0x6E,0x3B,0x4A,0x16,0x1F,0xD6,0x69,0xB4,0xAB,0xE6,0x64,0x89,0xAB,0x89,0x05,0x71,0x17,0x36,0x27,0x38,0xB1,0x49,0x08,0x01,0x81,0xA4,0x23,0xE3,0xE8,0xFE,0xC4,0x9E,0xC2,0xD7,0x10,0x87,0xA5,0x58,0xA3,0x72,0x24,0xA6,0xC8,0x65};
//    size_t expectedUnblindedSignatureLength = sizeof(expectedUnblindedSignature) / sizeof(uint8_t);
//    NSData *expectedUnblindedSignatureData = [NSData dataWithBytes:expectedUnblindedSignature length:expectedUnblindedSignatureLength];
//
//    uint8_t unblindedSignature[keyLengthBytes];
//    size_t unblindedSignatureLength = sizeof(unblindedSignature) / sizeof(uint8_t);
//    
//    int result = unblindSignature(modulus, modulusLength, blindingFactor, blindingFactorLength, blindedSignature, blindedSignatureLength, unblindedSignature, &unblindedSignatureLength);
//
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Message unblinding failed.");
//
//    NSData *unblindedSignatureData = [NSData dataWithBytes:unblindedSignature length:unblindedSignatureLength];
//    XCTAssertTrue([unblindedSignatureData isEqualToData:expectedUnblindedSignatureData], @"Unblinded signature is incorrect.");
//    
//}

//- (void)testGenerateRandomInteger
//{
//    int bitCount = 4096;
//    mp_int randomInteger1, randomInteger2;
//
//    // Initialise the big integers
//    int mpResult = mp_init_multi(&randomInteger1, &randomInteger2, NULL);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Init of integerS failed.");
//    
//    int result = generateRandomInteger(bitCount, &randomInteger1);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Generate random integer 1 failed.");
//    
//    int bitCount1 = mp_count_bits(&randomInteger1);
//    XCTAssertTrue(bitCount1 <= bitCount, @"Random integer 1 has more bits than requested");
//    
//    result = generateRandomInteger(bitCount, &randomInteger2);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Generate 2 random integer 2 failed.");
//
//    int bitCount2 = mp_count_bits(&randomInteger2);
//    XCTAssertTrue(bitCount2 <= bitCount, @"Random integer 2 has more bits than requested");
//    
//    XCTAssertTrue(mp_cmp(&randomInteger1, &randomInteger2) != MP_EQ, @"Identical 'random' integers generated. Should be random.");
//    
//    int stringSizeNeeded1, stringSizeNeeded2;
//    mpResult = mp_radix_size(&randomInteger1, 16, &stringSizeNeeded1);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Get string 1 size failed.");
//    
//    mpResult = mp_radix_size(&randomInteger2, 16, &stringSizeNeeded2);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Get string 2 size failed.");
//    
//    char *outputString1, *outputString2;
//    
//    outputString1 = malloc(stringSizeNeeded1);
//    XCTAssertTrue(outputString1 != NULL, @"Malloc for string 1 failed.");
//    
//    outputString2 = malloc(stringSizeNeeded2);
//    XCTAssertTrue(outputString2 != NULL, @"Malloc for string 2 failed.");
//
//    mpResult = mp_toradix(&randomInteger1, outputString1, 16);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Output to string 1 failed.");
//    
//    mpResult = mp_toradix(&randomInteger2, outputString2, 16);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Output to string 2 failed.");
//
//    // Free up memory
//    mp_clear_multi(&randomInteger1, &randomInteger2, NULL);
//    free(outputString1);
//    free(outputString2);
//}
//
//- (void)testGenerateRandomIntegerLessThanAnother
//{
//    int byteCount = 164;
//    mp_int comparisonInteger, randomInteger;
//    
//    // Initialise the big integers
//    int mpResult = mp_init_multi(&comparisonInteger, &randomInteger, NULL);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Init of integerS failed.");
//    
//    int result = generateRandomInteger(byteCount, &comparisonInteger);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Generate comparison integer failed.");
//    
//    result = generateRandomIntegerLessThanAnother(&randomInteger, &comparisonInteger);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Generate random integer failed.");
//    
//    XCTAssertTrue(mp_cmp(&randomInteger, &comparisonInteger) != MP_EQ, @"Identical 'random' integers generated. Should be random.");
//    
//    XCTAssertTrue(mp_cmp(&randomInteger, &comparisonInteger) == MP_LT, @"Generated random integer was not less than other integer.");
//
//    int stringSizeNeeded1, stringSizeNeeded2;
//    mpResult = mp_radix_size(&comparisonInteger, 16, &stringSizeNeeded1);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Get string 1 (comparison integer) size failed.");
//    
//    mpResult = mp_radix_size(&randomInteger, 16, &stringSizeNeeded2);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Get string 2 (random integer) size failed.");
//    
//    char *outputString1, *outputString2;
//    
//    outputString1 = malloc(stringSizeNeeded1);
//    XCTAssertTrue(outputString1 != NULL, @"Malloc for string 1 (comparison integer) failed.");
//    
//    outputString2 = malloc(stringSizeNeeded2);
//    XCTAssertTrue(outputString2 != NULL, @"Malloc for string 2 (random integer) failed.");
//    
//    mpResult = mp_toradix(&comparisonInteger, outputString1, 16);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Output to string 1 (comparison integer) failed.");
//    
//    mpResult = mp_toradix(&randomInteger, outputString2, 16);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Output to string 2 (random integer) failed.");
//    
//    // Free up memory
//    mp_clear_multi(&comparisonInteger, &randomInteger, NULL);
//    free(outputString1);
//    free(outputString2);
//}

//- (void)testGenerateBlindingFactor
//{
//    uint8_t modulusArray[] = {0x9C,0x59,0xCE,0xDB,0xAD,0x8B,0x9A,0x7F,0xAD,0xC2,0xD6,0x1F,0x06,0x3D,0x17,0x5C,0x1D,0x10,0x1C,0x62,0x57,0x10,0xC9,0xB6,0xA6,0x49,0xBE,0x0C,0xF0,0x89,0x66,0x1B,0xA1,0xBB,0x48,0xC2,0x5A,0xAB,0x92,0xDB,0x6F,0x1A,0x2F,0x80,0x74,0x1D,0xDD,0xCC,0x80,0xF3,0x01,0x59,0x4E,0xB5,0x6F,0x2A,0x7E,0x63,0x1F,0xE4,0xFB,0xA1,0xEB,0x98,0xB3,0x32,0xBA,0x1C,0xA7,0x23,0x49,0x7F,0xCD,0xAE,0x32,0x88,0xF5,0x55,0xC4,0x96,0x64,0xC8,0x32,0x5F,0x31,0x83,0x43,0x5B,0x4C,0xB2,0x1C,0xC6,0x3C,0x50,0xB2,0x35,0xF2,0xF5,0x08,0x0D,0x77,0xDB,0x14,0x8C,0xA1,0xAE,0x3A,0x5B,0x80,0x5C,0x04,0x10,0x5E,0xD9,0x5C,0x73,0xC6,0xAC,0xAA,0x30,0xFC,0x75,0x85,0x64,0x58,0x08,0x70,0xC9};
//    size_t modulusArrayLength = sizeof(modulusArray) / sizeof(uint8_t);
//    
//    mp_int modulus, blindingFactor;
//    
//    // Initialise the big integers
//    int mpResult = mp_init_multi(&modulus, &blindingFactor, NULL);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Integer initialisation failed.");
//    
//    mpResult = mp_read_unsigned_bin(&modulus, modulusArray, (int)modulusArrayLength);
//    XCTAssertTrue(mpResult == MP_OKAY, @"Integer assignment failed.");
//
//    int result = generateBlindingFactor(&modulus, &blindingFactor);
//    XCTAssertTrue(result == QREDO_BLINDING_SUCCESS, @"Blinding factor generation failed.");
//    
//    // Free up memory
//    mp_clear_multi(&modulus, &blindingFactor, NULL);
//}
@end
